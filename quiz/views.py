# import random
# import requests
# from collections import defaultdict
# from django.contrib.auth.decorators import login_required
# from django.contrib.auth.forms import UserCreationForm
# from django.http import JsonResponse
# from django.shortcuts import render, redirect, get_object_or_404
# from .models import Question, QuestionRecord, QuestionBookmark
# from django.urls import reverse
# from django.http import JsonResponse
# from django.views.decorators.http import require_GET, require_POST
# from django.contrib import messages
# from urllib.parse import urlencode, urlparse, parse_qs
# from django.utils.http import urlencode
# from django.views.decorators.csrf import csrf_exempt
# from .models import ExamSession
# from django.utils.timezone import localtime
# from django.utils import timezone
# from opencc import OpenCC


# # ========== Â∑•ÂÖ∑ÂáΩÂºè ==========
# cc = OpenCC("s2t")  # Á∞°È´îËΩâÁπÅÈ´î


# def convert_to_traditional(text):
#     return cc.convert(text)


# def check_answer(question, selected_answer, fill_input):
#     correct_answer = question.answer.upper()
#     if question.is_fill_in:
#         return fill_input.strip() == question.fill_answer.strip()
#     else:
#         user_ans = "".join(selected_answer).strip().upper()
#         return (
#             user_ans == correct_answer
#             if question.require_order
#             else sorted(user_ans) == sorted(correct_answer)
#         )


# def sort_key(val):
#     try:
#         cleaned = val.replace(" ", "")
#         if "-" in cleaned:
#             parts = cleaned.split("-")
#             return (int(parts[0]), int(parts[1]))
#         return (int(cleaned), 0)
#     except Exception:
#         return (float("inf"), float("inf"))


# def get_chapters_by_category(request):
#     category = request.GET.get("category")
#     chapters = list(
#         Question.objects.filter(category=category)
#         .values_list("chapter", flat=True)
#         .distinct()
#     )
#     return JsonResponse({"chapters": chapters})


# def get_ai_feedback_ollama(
#     question_text,
#     user_ans,
#     correct_ans,
#     question=None,
#     category=None,
#     options="",
#     model_name="qwen2.5-coder:7b",
# ):
#     print(f"üß™ DEBUGÔºö‰ΩøÁî®Ê®°Âûã = {model_name}")
#     """
#     ÂõûÂÇ≥ AI Ëß£ÈáãË™™ÊòéÊñáÂ≠óÔºåÂåÖÂê´È°ûÂà•Âº∑ÂåñÊèêÁ§∫
#     """

#     # Èò≤ÂëÜËôïÁêÜ
#     user_ans = user_ans or "ÔºàÊú™Êèê‰æõÔºâ"
#     correct_ans = correct_ans or "ÔºàÊú™Êèê‰æõÔºâ"

#     # È°ûÂà•ÔºöÂÑ™ÂÖà‰ΩøÁî® categoryÔºåÂê¶ÂâáÂæû question Êì∑Âèñ
#     category_text = category or (getattr(question, "category", "") or "").strip()
#     if not category_text:
#         print(
#             f"DEBUG: category = {category}, question.category = {getattr(question, 'category', None)}"
#         )

#     # Ëá™ÂãïÊì∑ÂèñÈÅ∏È†ÖÔºàËã•Êú™ÊâãÂãïÂÇ≥ÂÖ•Ôºâ
#     if not options and question:
#         for letter in "ABCDEFGH":
#             choice_text = getattr(question, f"choice_{letter.lower()}", "").strip()
#             if choice_text and choice_text.upper() != "X":
#                 options += f"{letter}. {choice_text}\n"

#     # Âº∑ÂåñÁâà promptÔºåËÆìÊ®°Âûã‰∏ÄÂÆöËÆÄÂà∞È°ûÂà•
#     prompt = f"""Ë´ã‰ΩøÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î„ÄÇ
# ÈÄôÊòØ‰∏ÄÈ°åÈÅ∏ÊìáÈ°åÔºåË´ãÂπ´ÊàëËß£ÈáãÁÇ∫‰ªÄÈ∫ºÁ≠îÊ°à‰∏çÊòØ„Äå{user_ans}„ÄçÔºåËÄåÊòØ„Äå{correct_ans}„Äç„ÄÇ

# Ë´ãÁâπÂà•Ê†πÊìö„ÄåÈ°åÁõÆÁØÑÂúç„ÄçÊÄùËÄÉËß£Èáã„ÄÇ
# ÁßëÁõÆÁØÑÂúçÔºö„Äå{category_text or 'Êú™Êèê‰æõ'}„Äç

# È°åÁõÆÂÖßÂÆπÂ¶Ç‰∏ãÔºö
# {question_text}

# ÈÅ∏È†ÖÂ¶Ç‰∏ãÔºö
# {options}
# """.strip()

#     try:
#         response = requests.post(
#             "http://localhost:11434/api/generate",
#             json={
#                 "model": model_name,
#                 "prompt": prompt,
#                 "stream": False,
#             },
#             timeout=180,
#         )
#         data = response.json()
#         return f"ü§ñ Êú¨Ê¨°ÂõûÁ≠îÁî±„Äå{model_name}„ÄçÊ®°ÂûãÁîüÊàêÔºö\n\n{data.get('response', '‚ö†Ô∏è AI Ê≤íÊúâÂõûÊáâ„ÄÇ')}"
#     except Exception as e:
#         return f"‚ö†Ô∏è AI Ë´ãÊ±ÇÈåØË™§Ôºö{e}"


# # ========== È°åÁõÆË¶ñÂúñ ==========


# @login_required
# def question_detail(request, pk):
#     question = get_object_or_404(Question, pk=pk)
#     return render(request, "quiz/question_detail.html", {"question": question})


# def question_list(request):
#     questions = Question.objects.all()
#     return render(request, "quiz/question_list.html", {"questions": questions})


# def select_category(request):
#     categories = Question.objects.values_list("category", flat=True).distinct()
#     return render(request, "quiz/select_category.html", {"categories": categories})


# def get_numbers_by_chapter(request):
#     category = request.GET.get("category")
#     chapter = request.GET.get("chapter")
#     numbers = list(
#         Question.objects.filter(category=category, chapter=chapter)
#         .values_list("number", flat=True)
#         .distinct()
#     )
#     return JsonResponse({"numbers": numbers})


# def shuffle_choice_values(question):
#     import random

#     # ‚úÖ ÊéíÈô§Â°´ÂÖÖÈ°åÔºàÂõ†ÁÇ∫ÂÆÉÊ≤íÊúâÈÅ∏È†ÖÔºâ
#     if question.is_fill_in:
#         return {}, ""  # ‰∏çÈúÄË¶ÅÈÅ∏È†ÖÔºå‰πüÊ≤íÊúâÊ≠£Á¢∫ÈÅ∏È†ÖÂ≠óÊØç

#     # Á¢∫‰øùÁ≠îÊ°àÊòØÂ≠ó‰∏≤
#     if not isinstance(question.answer, str):
#         raise ValueError(
#             f"‚ùå answer ÊáâÁÇ∫Â≠ó‰∏≤Ôºå‰ΩÜÊî∂Âà∞Ôºö{type(question.answer).__name__} -> {question.answer}"
#         )

#     answer_letters = question.answer.strip().upper().replace(",", "")
#     if not all(c.isalpha() for c in answer_letters):
#         raise ValueError(f"‚ùå ÁÑ°ÊïàÁöÑÁ≠îÊ°àÊ†ºÂºèÔºö{question.answer}")

#     # ÊâÄÊúâÈÅ∏È†Ö
#     choices = {
#         "A": question.choice_a,
#         "B": question.choice_b,
#         "C": question.choice_c,
#         "D": question.choice_d,
#         "E": question.choice_e,
#         "F": question.choice_f,
#         "G": question.choice_g,
#         "H": question.choice_h,
#     }

#     # ÈÅéÊøæÁÇ∫Á©∫Êàñ "X" ÁöÑÈÅ∏È†Ö
#     valid_choices = {k: v for k, v in choices.items() if v and v.strip().upper() != "X"}

#     # Êâì‰∫ÇÈ†ÜÂ∫è
#     items = list(valid_choices.items())
#     random.shuffle(items)

#     shuffled = {}
#     old_to_new = {}
#     for idx, (old_letter, content) in enumerate(items):
#         new_letter = chr(ord("A") + idx)
#         shuffled[new_letter] = content
#         old_to_new[old_letter] = new_letter

#     # ËΩâÊèõÁ≠îÊ°àÂà∞Êñ∞È†ÜÂ∫è
#     new_answer = "".join([old_to_new[l] for l in answer_letters if l in old_to_new])

#     return shuffled, new_answer


# # ========== Á∑¥ÁøíËàáÊ®°Êì¨Ê∏¨È©ó ==========


# @login_required
# def mock_exam(request):
#     category = request.GET.get("category")
#     chapter = request.GET.get("chapter")
#     number = request.GET.get("number")

#     if category == "None":
#         category = None
#     if chapter == "None":
#         chapter = None
#     if number == "None":
#         number = None

#     model_name = request.session.get("ollama_model", "qwen2.5-coder:7b")
#     ollama_enabled = request.session.get("ollama_enabled", True)

#     result = None
#     correct_answer = None
#     explanation = None
#     selected_answer = []
#     fill_input = ""
#     ai_explanation = None
#     used_time = int(request.POST.get("used_time", 0))

#     questions = Question.objects.order_by("chapter", "number_order")
#     if category:
#         questions = questions.filter(category=category)
#     if chapter:
#         questions = questions.filter(chapter=chapter)
#     if number:
#         questions = questions.filter(number=number)

#     total = questions.count()
#     category_total = (
#         Question.objects.filter(category=category).count() if category else 0
#     )

#     if total == 0:
#         return render(
#             request,
#             "quiz/chapter_practice.html",
#             {
#                 "no_question": True,
#                 "category": category,
#                 "chapter": chapter,
#                 "number": number,
#                 "category_total": category_total,
#             },
#         )

#     query_params = urlencode(
#         {
#             "category": category or "",
#             "chapter": chapter or "",
#             "number": number or "",
#         }
#     )
#     redirect_url = f"{reverse('mock_exam')}?{query_params}"

#     if request.method == "POST" and ("next" in request.POST or "skip" in request.POST):
#         return redirect(redirect_url)

#     if request.method == "POST":
#         question_id = request.POST.get("question_id")
#         question = get_object_or_404(Question, id=question_id)

#         shuffled_choices = request.session.get("shuffled_choices")
#         correct_answer = request.session.get("correct_answer")

#         if not question.is_fill_in and correct_answer:
#             question.answer = correct_answer

#         selected_answer = request.POST.getlist("selected_answer")
#         fill_input = request.POST.get("fill_answer", "").strip()
#         used_time = int(request.POST.get("used_time", 0))

#         explanation = question.explanation
#         result = check_answer(question, selected_answer, fill_input)

#         if not result:
#             if ollama_enabled and not question.image:
#                 options_text = ""
#                 for letter in "ABCDEFGH":
#                     choice = getattr(question, f"choice_{letter.lower()}", None)
#                     if choice and choice.strip().upper() != "X":
#                         options_text += f"{letter}. {choice}\n"

#                 ai_explanation = get_ai_feedback_ollama(
#                     question_text=question.question_text,
#                     user_ans=(
#                         fill_input if question.is_fill_in else "".join(selected_answer)
#                     ),
#                     correct_ans=correct_answer,
#                     question=question,
#                     options=options_text,
#                     model_name=model_name,
#                 )
#                 ai_explanation = convert_to_traditional(ai_explanation)
#             else:
#                 ai_explanation = convert_to_traditional(question.explanation)
#         else:
#             ai_explanation = None

#         if request.user.is_authenticated:
#             QuestionRecord.objects.create(
#                 user=request.user,
#                 question=question,
#                 is_correct=result,
#                 selected_answer=(
#                     fill_input if question.is_fill_in else "".join(selected_answer)
#                 ),
#                 used_time=used_time,
#                 ai_explanation=ai_explanation if not result else None,
#                 source="mock",
#             )

#     else:
#         question = random.choice(questions)
#         if not question.is_fill_in:
#             shuffled_choices, new_answer = shuffle_choice_values(question)
#             request.session["shuffled_choices"] = shuffled_choices
#             request.session["correct_answer"] = new_answer
#             question.answer = new_answer
#         else:
#             shuffled_choices = None
#             request.session["shuffled_choices"] = None
#             request.session["correct_answer"] = question.fill_answer

#     # ‰∏ãÊãâË≥áÊñô
#     categories = Question.objects.values_list("category", flat=True).distinct()
#     chapter_list = (
#         Question.objects.filter(category=category)
#         .values_list("chapter", flat=True)
#         .distinct()
#         if category
#         else []
#     )
#     number_list = []
#     current_chapter = chapter or getattr(question, "chapter", None)
#     if category and current_chapter:
#         raw_numbers = (
#             Question.objects.filter(category=category, chapter=current_chapter)
#             .values_list("number", flat=True)
#             .distinct()
#         )
#         number_list = sorted(raw_numbers, key=sort_key)

#     correct_answer = request.session.get("correct_answer")
#     correct_answer_list = list(correct_answer) if correct_answer else []
#     correct_choices_list = [
#         getattr(question, f"choice_{letter.lower()}", "")
#         for letter in correct_answer_list
#         if getattr(question, f"choice_{letter.lower()}", "").strip().upper() != "X"
#     ]

#     is_favorited = QuestionBookmark.objects.filter(
#         user=request.user, question=question, bookmark_type="favorite"
#     ).exists()

#     is_flagged = QuestionBookmark.objects.filter(
#         user=request.user, question=question, bookmark_type="flag"
#     ).exists()

#     return render(
#         request,
#         "quiz/mock_exam.html",
#         {
#             "question": question,
#             "selected_answer": selected_answer,
#             "fill_input": fill_input,
#             "result": result,
#             "correct_answer": correct_answer,
#             "correct_answer_list": correct_answer_list,
#             "correct_choices_list": correct_choices_list,
#             "explanation": explanation,
#             "ai_explanation": ai_explanation,
#             "category": category,
#             "chapter": chapter,
#             "number": number,
#             "chapter_list": chapter_list,
#             "number_list": number_list,
#             "categories": categories,
#             "current_category": category,
#             "category_total": category_total,
#             "shuffled_choices": request.session.get("shuffled_choices"),
#             "ollama_model": model_name,
#             "is_favorited": is_favorited,
#             "is_flagged": is_flagged,
#             "used_time": used_time,
#         },
#     )


# @login_required
# def reset_chapter_practice(request):
#     request.session.pop("question_ids", None)
#     request.session.pop("current_index", None)
#     return redirect("chapter_practice")


# @login_required
# def chapter_practice(request):
#     category = request.GET.get("category")
#     chapter = request.GET.get("chapter")
#     number = request.GET.get("number")
#     if category == "None":
#         category = None
#     if chapter == "None":
#         chapter = None
#     if number == "None":
#         number = None

#     # È°åÂ∫´Êü•Ë©¢
#     questions = Question.objects.order_by("chapter", "number_order")
#     if category:
#         questions = questions.filter(category=category)
#     if chapter:
#         questions = questions.filter(chapter=chapter)
#     if number:
#         questions = questions.filter(number=number)

#     total = questions.count()
#     category_total = (
#         Question.objects.filter(category=category).count() if category else 0
#     )

#     if total == 0:
#         return render(
#             request,
#             "quiz/chapter_practice.html",
#             {
#                 "no_question": True,
#                 "category": category,
#                 "chapter": chapter,
#                 "number": number,
#                 "category_total": category_total,
#                 "question": None,
#             },
#         )

#     # ÂàáÊèõÈ°åÁõÆÈÇèËºØ
#     if request.method == "GET" and request.GET.get("next") == "1":
#         request.session["current_index"] = request.session.get("current_index", 0) + 1
#         return redirect(
#             f"{reverse('chapter_practice')}?{urlencode({'category': category or '', 'chapter': chapter or '', 'number': number or ''})}"
#         )

#     current_index = request.session.get("current_index", 0)
#     if current_index >= total:
#         current_index = 0

#     selected_answer = []
#     fill_input = ""
#     result = None
#     correct_answer = None
#     ai_explanation = None
#     question = questions[current_index]

#     query_params = urlencode(
#         {"category": category or "", "chapter": chapter or "", "number": number or ""}
#     )
#     redirect_url = f"{reverse('chapter_practice')}?{query_params}"

#     if request.method == "POST":
#         if "restart" in request.POST:
#             request.session["current_index"] = 0
#             return redirect(redirect_url)

#         elif "skip" in request.POST or "next" in request.POST:
#             request.session["current_index"] = current_index + 1
#             return redirect(redirect_url)

#         elif "prev" in request.POST:
#             request.session["current_index"] = max(current_index - 1, 0)
#             return redirect(redirect_url)

#         # ‚úÖ ‰ΩúÁ≠îÈÇèËºØ
#         selected_answer = [a.upper() for a in request.POST.getlist("selected_answer")]
#         fill_input = request.POST.get("fill_answer", "").strip()
#         used_time = request.POST.get("used_time", 0)

#         result = check_answer(question, selected_answer, fill_input)
#         correct_answer = question.answer  # Â¶Ç AC

#         # ‚úÖ AI Ëß£ÈáãÔºàÂÉÖÁ≠îÈåØÔºâ
#         if not result:
#             ollama_enabled = request.session.get("ollama_enabled", True)
#             model_name = request.session.get("ollama_model", "qwen2.5-coder:7b")

#             if ollama_enabled and not question.image:
#                 options_text = generate_options_text(question)
#                 ai_explanation = get_ai_feedback_ollama(
#                     question_text=question.question_text,
#                     user_ans=(
#                         fill_input if question.is_fill_in else "".join(selected_answer)
#                     ),
#                     correct_ans=correct_answer,
#                     question=question.category,
#                     options=options_text,
#                     model_name=model_name,
#                 )
#                 ai_explanation = convert_to_traditional(ai_explanation)  # ‚úÖ Ê≠£Á¢∫ËΩâÁπÅÈ´î
#             else:
#                 ai_explanation = convert_to_traditional(question.explanation)
#         # ‚úÖ Âª∫Á´ãÁ≠îÈ°åÁ¥ÄÈåÑ
#         if request.user.is_authenticated:
#             QuestionRecord.objects.create(
#                 user=request.user,
#                 question=question,
#                 is_correct=result,
#                 selected_answer=(
#                     fill_input if question.is_fill_in else "".join(selected_answer)
#                 ),
#                 used_time=used_time,
#                 ai_explanation=ai_explanation if not result else None,
#                 source="mock",
#             )

#     # ‰∏ãÊãâÈÅ∏ÂñÆ
#     chapter_list = (
#         Question.objects.filter(category=category)
#         .values_list("chapter", flat=True)
#         .distinct()
#     )
#     if category and chapter:
#         number_list = (
#             Question.objects.filter(category=category, chapter=chapter)
#             .values_list("number", flat=True)
#             .distinct()
#         )
#     else:
#         number_list = []

#     categories = Question.objects.values_list("category", flat=True).distinct()

#     # ‚úÖ ÁµÑÂá∫Ê≠£Á¢∫ÈÅ∏È†ÖÁöÑÊñáÂ≠óÔºàÈùû A/B/C ËÄåÊòØÂØ¶ÈöõÂÖßÂÆπÔºâ
#     correct_answer_list = list(correct_answer) if correct_answer else []

#     correct_choices_list = [
#         getattr(question, f"choice_{letter.lower()}")
#         for letter in correct_answer_list
#         if getattr(question, f"choice_{letter.lower()}", "").strip().upper() != "X"
#     ]
#     is_favorited = QuestionBookmark.objects.filter(
#         user=request.user, question=question, bookmark_type="favorite"
#     ).exists()

#     is_flagged = QuestionBookmark.objects.filter(
#         user=request.user, question=question, bookmark_type="flag"
#     ).exists()

#     return render(
#         request,
#         "quiz/chapter_practice.html",
#         {
#             "question": question,
#             "selected_answer": selected_answer,
#             "fill_input": fill_input,
#             "result": result,
#             "correct_answer": correct_answer,
#             "ai_explanation": ai_explanation,
#             "total_question_count": total,
#             "current_index": current_index,
#             "chapter_list": chapter_list,
#             "number_list": number_list,
#             "categories": categories,
#             "current_category": category,
#             "category": category,
#             "chapter": chapter,
#             "number": number,
#             "category_total": category_total,
#             "ollama_model": request.session.get("ollama_model", "qwen2.5-coder:7b"),
#             "options": generate_options_text(question),
#             "correct_answer_list": correct_answer_list,
#             "correct_choices_list": correct_choices_list,
#             "is_favorited": is_favorited,
#             "is_flagged": is_flagged,
#         },
#     )


# # ========== Ê≠∑Âè≤ËàáË§áÁøí ==========


# @login_required
# def exam_history(request):
#     category = request.GET.get("category")

#     records = (
#         QuestionRecord.objects.filter(user=request.user)
#         .select_related("question")
#         .order_by("-answered_at")
#     )
#     if category:
#         records = records.filter(question__category=category)

#     grouped = defaultdict(list)
#     for r in records:
#         date = localtime(r.answered_at).date()
#         grouped[date].append(r)

#     grouped_records = sorted(grouped.items(), reverse=True)
#     categories = Question.objects.values_list("category", flat=True).distinct()

#     return render(
#         request,
#         "quiz/exam_history.html",
#         {
#             "grouped_records": grouped_records,
#             "current_category": category,
#             "categories": categories,
#         },
#     )


# @login_required
# def review_wrong_questions(request):
#     category = request.GET.get("category")

#     # Êü•Êâæ‰ΩøÁî®ËÄÖÁöÑÈåØÈ°åÁ¥ÄÈåÑ
#     wrong_records = (
#         QuestionRecord.objects.filter(user=request.user, is_correct=False)
#         .select_related("question")
#         .order_by("-answered_at")
#     )
#     if category:
#         wrong_records = wrong_records.filter(question__category=category)

#     # Âè™‰øùÁïô question Â≠òÂú®ÁöÑÁ¥ÄÈåÑ
#     questions = []
#     for record in wrong_records:
#         if record.question:
#             questions.append(record.question)

#     # ÂàÜÈ°ûÈÅ∏ÂñÆ
#     categories = Question.objects.values_list("category", flat=True).distinct()

#     # Âª∫Á´ãÊØè‰∏ÄÈ°åÁöÑÊî∂ËóèËàáÁà≠Ë≠∞ÁãÄÊÖãÂ∞çÁÖßË°®
#     bookmark_status = {}
#     for q in questions:
#         bookmark_status[q.id] = {
#             "is_favorited": QuestionBookmark.objects.filter(
#                 user=request.user, question=q, bookmark_type="favorite"
#             ).exists(),
#             "is_flagged": QuestionBookmark.objects.filter(
#                 user=request.user, question=q, bookmark_type="flag"
#             ).exists(),
#         }

#     return render(
#         request,
#         "quiz/review_wrong_questions.html",
#         {
#             "questions": questions,
#             "records": wrong_records,
#             "categories": categories,
#             "current_category": category,
#             "bookmark_status": bookmark_status,
#         },
#     )


# @require_GET
# def toggle_ollama(request):
#     enable = request.GET.get("enable") == "true"
#     request.session["ollama_enabled"] = enable
#     return JsonResponse({"status": "ok", "enabled": enable})


# def clear_ollama_notice(request):
#     request.session.pop("show_ollama_notice", None)
#     return JsonResponse({"cleared": True})


# def set_ollama_model(request):
#     model = request.GET.get("model")
#     print(f"üß™ ÂæåÁ´ØÊî∂Âà∞Ê®°ÂûãË®≠ÂÆöÔºö{model}")
#     if model:
#         request.session["ollama_model"] = model
#         print("üß™ Â∑≤ÂØ´ÂÖ• session")
#     return JsonResponse({"status": "ok", "model": model})


# def register(request):
#     if request.method == "POST":
#         form = UserCreationForm(request.POST)
#         if form.is_valid():
#             form.save()
#             return redirect("login")
#     else:
#         form = UserCreationForm()

#     return render(request, "registration/register.html", {"form": form})


# def is_ollama_running():
#     try:
#         response = requests.get("http://localhost:11434")
#         return response.status_code == 200
#     except:
#         return False


# # def is_ollama_running():
# #     try:
# #         response = requests.get("http://192.168.0.101:11434/api/tags", timeout=3)
# #         return response.status_code == 200
# #     except Exception:
# #         return False


# @login_required
# @require_POST
# def save_ai_explanation(request, pk):
#     question = get_object_or_404(Question, pk=pk)
#     new_explanation = request.POST.get("explanation")

#     if new_explanation:
#         question.explanation = new_explanation
#         question.save()
#         messages.success(request, "‚úÖ Ëß£ÈáãÂ∑≤ÊàêÂäüÂØ´ÂÖ•")
#     else:
#         messages.warning(request, "‚ö†Ô∏è Ê≤íÊúâÊî∂Âà∞Ëß£ÈáãÂÖßÂÆπ")

#     # ‚è© ÂõûÂà∞‰æÜÊ∫êÈ†ÅÈù¢‰∏¶Ëß∏Áôº‰∏ã‰∏ÄÈ°å
#     referer = request.META.get("HTTP_REFERER", "/")
#     parsed = urlparse(referer)
#     base_url = parsed.path
#     query = parse_qs(parsed.query)
#     query["next"] = ["1"]

#     return redirect(f"{base_url}?{urlencode(query, doseq=True)}")


# @csrf_exempt
# @login_required
# @require_POST
# def ask_ai_followup(request):
#     question_text = request.POST.get("question_text", "")
#     category = request.POST.get("category", "")
#     options = request.POST.get("options", "")
#     followup = request.POST.get("followup", "")
#     chat_history = request.POST.get("chat_history", "")

#     prompt = f"""‰ª•‰∏ãÊòØ‰ΩøÁî®ËÄÖËàá AI ÁöÑÈÅéÂæÄÂ∞çË©±Ôºö

# {chat_history.strip()}

# ---

# ÂéüÂßãÈ°åÁõÆÔºö
# {question_text}

# ÁØÑÂúçÔºö„Äå{category}„Äç
# ÈÅ∏È†ÖÔºö
# {options}

# ‰ΩøÁî®ËÄÖÁöÑÊñ∞ÂïèÈ°åÔºö
# {followup}

# Ë´ãÁî®ÁπÅÈ´î‰∏≠ÊñáÂõûÁ≠î„ÄÇ
# """

#     response = requests.post(
#         "http://localhost:11434/api/generate",
#         json={"model": "qwen2.5-coder:7b", "prompt": prompt, "stream": False},
#         timeout=90,
#     )
#     data = response.json()
#     reply = data.get("response", "‚ö†Ô∏è AI Ê≤íÊúâÂõûÊáâ„ÄÇ")

#     return render(request, "quiz/_followup_result.html", {"reply": reply})


# def generate_options_text(question):
#     """
#     Ê†πÊìöÈ°åÁõÆËá™ÂãïÁî¢ÁîüÈÅ∏È†ÖÊñáÂ≠óÔºà‰∏çÂê´ "X" ÁöÑÈÅ∏È†ÖÔºâÔºåÁµ¶ AI Áî®ÁöÑÊèêÁ§∫Ê†ºÂºè„ÄÇ
#     """
#     options_text = ""
#     for letter in "ABCDEFGH":
#         choice = getattr(question, f"choice_{letter.lower()}", "").strip()
#         if choice and choice.upper() != "X":
#             options_text += f"{letter}. {choice}\n"
#     return options_text


# @login_required
# def exam_start(request):
#     categories = Question.objects.values_list("category", flat=True).distinct()
#     category = request.GET.get("category") or request.session.get("exam_category")

#     if not category:
#         return render(
#             request,
#             "quiz/exam_start.html",
#             {
#                 "categories": categories,
#                 "current_category": None,
#                 "total_available": 0,
#                 "question_options": [],
#                 "last_session": None,
#             },
#         )

#     request.session["exam_category"] = category
#     all_questions = Question.objects.filter(category=category).order_by("number_order")
#     total_available = all_questions.count()

#     # ‚úÖ Âõ∫ÂÆöÈÅ∏È†ÖÔºö[5, 15, 30, 50, 'all']Ôºå‰ΩÜÂè™ÂåÖÂê´ total_available ‰ª•‰∏äÁöÑÈÅ∏È†Ö
#     question_options = [x for x in [5, 15, 30, 50] if total_available >= x]
#     if total_available >= 1:
#         question_options.append("all")

#     if request.method == "POST":
#         total = request.POST.get("total_questions")

#         if total == "all":
#             total = total_available
#         else:
#             try:
#                 total = int(total)
#             except (ValueError, TypeError):
#                 return redirect("exam_start")  # fallback

#         selected_questions = list(all_questions.order_by("?")[:total])

#         session = ExamSession.objects.create(
#             user=request.user,
#             category=category,
#             total_questions=total,
#         )
#         session.questions.set(selected_questions)

#         return redirect("exam_question", session_id=session.id)

#     last_session = (
#         ExamSession.objects.filter(user=request.user, is_submitted=True)
#         .order_by("-created_at")
#         .first()
#     )

#     return render(
#         request,
#         "quiz/exam_start.html",
#         {
#             "categories": categories,
#             "current_category": category,
#             "total_available": total_available,
#             "question_options": question_options,
#             "last_session": last_session,
#         },
#     )


# @login_required
# def exam_question(request, session_id):
#     session = get_object_or_404(ExamSession, id=session_id, user=request.user)
#     questions = session.questions.all().order_by("id")
#     total = questions.count()
#     used_time = int(request.POST.get("used_time", 0))

#     answered_question_ids = QuestionRecord.objects.filter(
#         exam_session=session
#     ).values_list("question_id", flat=True)
#     current_index = len(answered_question_ids)

#     if current_index >= total:
#         return redirect("exam_submit", session_id=session.id)

#     current_question = questions[current_index]

#     # ‚úÖ Step 1: Ëã•ÊòØ GETÔºåÊâì‰∫ÇÈÅ∏È†Ö‰∏¶Â≠òÂÖ• session
#     if request.method == "GET":
#         if not current_question.is_fill_in:
#             shuffled_choices, new_answer = shuffle_choice_values(current_question)
#             request.session["exam_shuffled_choices"] = shuffled_choices
#             request.session["exam_correct_answer"] = new_answer
#             current_question.answer = new_answer  # Áî®Êñ∞Á≠îÊ°à‰æÜÊØîÂ∞ç
#         else:
#             request.session["exam_shuffled_choices"] = None
#             request.session["exam_correct_answer"] = current_question.fill_answer

#     if request.method == "POST":
#         selected = request.POST.getlist("selected_answer")
#         fill_answer = request.POST.get("fill_answer", "").strip()

#         def clean_ans(ans):
#             return ans.strip().upper().replace("`", "")

#         # ‚úÖ Step 2: ÊîπÁÇ∫Âæû session ËÆÄÂèñÊ≠£Á¢∫Á≠îÊ°à
#         correct_answer = sorted(
#             [c for c in clean_ans(request.session.get("exam_correct_answer", ""))]
#         )
#         user_answer = sorted([clean_ans(s) for s in selected])

#         if current_question.require_order:
#             is_correct = user_answer == correct_answer
#         else:
#             is_correct = set(user_answer) == set(correct_answer)

#         QuestionRecord.objects.create(
#             user=request.user,
#             question=current_question,
#             selected_answer=",".join(user_answer),
#             fill_answer=fill_answer,
#             is_correct=is_correct,
#             exam_session=session,
#             source=f"Ê®°Êì¨ËÄÉÔºàÂÖ± {session.total_questions} È°åÔºâ",
#             used_time=used_time,
#             shuffled_choices=request.session.get("exam_shuffled_choices"),
#             shuffled_correct_answer=request.session.get("exam_correct_answer"),
#         )
#         return redirect("exam_question", session_id=session.id)

#     progress = round((current_index + 1) / total * 100)

#     # ‚úÖ Step 3: ÂÇ≥Áµ¶ template È°ØÁ§∫
#     return render(
#         request,
#         "quiz/exam_question.html",
#         {
#             "question": current_question,
#             "current_index": current_index,
#             "total_question_count": total,
#             "progress": progress,
#             "session": session,
#             "shuffled_choices": request.session.get("exam_shuffled_choices"),
#             "correct_answer": request.session.get("exam_correct_answer"),
#         },
#     )


# @login_required
# def exam_submit(request, session_id):
#     session = get_object_or_404(ExamSession, id=session_id, user=request.user)
#     total = session.total_questions
#     records = session.records.all()
#     correct = records.filter(is_correct=True).count()
#     percentage = round(correct / total * 100, 2) if total else 0

#     if not session.is_submitted:
#         session.score = percentage
#         session.finished_at = timezone.now()
#         session.is_submitted = True
#         session.save()

#     return redirect("exam_result", session_id=session.id)


# @login_required
# def exam_result(request, session_id):
#     session = get_object_or_404(ExamSession, id=session_id, user=request.user)
#     records = session.records.all()
#     total = session.total_questions
#     correct = records.filter(is_correct=True).count()
#     percentage = round(correct / total * 100, 2) if total else 0

#     past_sessions = ExamSession.objects.filter(
#         user=request.user, is_submitted=True
#     ).order_by("-created_at")

#     # üëâ Âπ´ÊØèÂÄã session Âä†‰∏äÈåØÈ°åÊï∏
#     for s in past_sessions:
#         s.correct_count = s.records.filter(is_correct=True).count()
#         s.wrong_count = s.total_questions - s.correct_count

#     wrong_questions = QuestionRecord.objects.filter(
#         exam_session=session, is_correct=False
#     ).select_related("question")

#     return render(
#         request,
#         "quiz/exam_result.html",
#         {
#             "session": session,
#             "records": records,
#             "correct_count": correct,
#             "total": total,
#             "percentage": percentage,
#             "past_sessions": past_sessions,
#             "wrong_questions": wrong_questions,
#         },
#     )


# @login_required
# @require_POST
# def toggle_bookmark(request):
#     question_id = request.POST.get("question_id")
#     bookmark_type = request.POST.get("bookmark_type")  # 'favorite' Êàñ 'flag'

#     if bookmark_type not in ["favorite", "flag"]:
#         return JsonResponse({"error": "‚ùå ÁÑ°ÊïàÁöÑÈ°ûÂûã"}, status=400)

#     question = get_object_or_404(Question, id=question_id)

#     bookmark, created = QuestionBookmark.objects.get_or_create(
#         user=request.user, question=question, bookmark_type=bookmark_type
#     )

#     if not created:
#         bookmark.delete()
#         return JsonResponse({"status": "removed"})
#     else:
#         return JsonResponse({"status": "added"})


# @login_required
# def bookmark_list(request):
#     favorite_bookmarks = QuestionBookmark.objects.filter(
#         user=request.user, bookmark_type="favorite"
#     ).select_related("question")
#     flagged_bookmarks = QuestionBookmark.objects.filter(
#         user=request.user, bookmark_type="flag"
#     ).select_related("question")

#     return render(
#         request,
#         "quiz/bookmark_list.html",
#         {
#             "favorite_questions": [b.question for b in favorite_bookmarks],
#             "flagged_questions": [b.question for b in flagged_bookmarks],
#         },
#     )
